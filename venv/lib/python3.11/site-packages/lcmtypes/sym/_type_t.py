# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs

import typing as T

from io import BytesIO
import enum
import struct

class type_t(enum.Enum):

    INVALID = 0
    SCALAR = 1
    ROT2 = 2
    ROT3 = 3
    POSE2 = 4
    POSE3 = 5
    UNIT3 = 7
    DATABUFFER = 6
    VECTORX = 10
    VECTOR1 = 11
    VECTOR2 = 12
    VECTOR3 = 13
    VECTOR4 = 14
    VECTOR5 = 15
    VECTOR6 = 16
    VECTOR7 = 17
    VECTOR8 = 18
    VECTOR9 = 19
    MATRIX12 = 20
    MATRIX13 = 21
    MATRIX14 = 22
    MATRIX15 = 23
    MATRIX16 = 24
    MATRIX17 = 25
    MATRIX18 = 26
    MATRIX19 = 27
    MATRIX22 = 28
    MATRIX23 = 29
    MATRIX24 = 30
    MATRIX25 = 31
    MATRIX26 = 32
    MATRIX27 = 33
    MATRIX28 = 34
    MATRIX29 = 35
    MATRIX32 = 36
    MATRIX33 = 37
    MATRIX34 = 38
    MATRIX35 = 39
    MATRIX36 = 40
    MATRIX37 = 41
    MATRIX38 = 42
    MATRIX39 = 43
    MATRIX42 = 44
    MATRIX43 = 45
    MATRIX44 = 46
    MATRIX45 = 47
    MATRIX46 = 48
    MATRIX47 = 49
    MATRIX48 = 50
    MATRIX49 = 51
    MATRIX52 = 52
    MATRIX53 = 53
    MATRIX54 = 54
    MATRIX55 = 55
    MATRIX56 = 56
    MATRIX57 = 57
    MATRIX58 = 58
    MATRIX59 = 59
    MATRIX62 = 60
    MATRIX63 = 61
    MATRIX64 = 62
    MATRIX65 = 63
    MATRIX66 = 64
    MATRIX67 = 65
    MATRIX68 = 66
    MATRIX69 = 67
    MATRIX72 = 68
    MATRIX73 = 69
    MATRIX74 = 70
    MATRIX75 = 71
    MATRIX76 = 72
    MATRIX77 = 73
    MATRIX78 = 74
    MATRIX79 = 75
    MATRIX82 = 76
    MATRIX83 = 77
    MATRIX84 = 78
    MATRIX85 = 79
    MATRIX86 = 80
    MATRIX87 = 81
    MATRIX88 = 82
    MATRIX89 = 83
    MATRIX92 = 84
    MATRIX93 = 85
    MATRIX94 = 86
    MATRIX95 = 87
    MATRIX96 = 88
    MATRIX97 = 89
    MATRIX98 = 90
    MATRIX99 = 91
    ATAN_CAMERA_CAL = 92
    DOUBLE_SPHERE_CAMERA_CAL = 93
    EQUIRECTANGULAR_CAMERA_CAL = 94
    LINEAR_CAMERA_CAL = 95
    POLYNOMIAL_CAMERA_CAL = 96
    SPHERICAL_CAMERA_CAL = 97

    def __repr__(self):
        # type: () -> str
        return "{}.{}".format(self.__class__.__name__, self.name)

    @staticmethod
    def _skytype_meta():
        # type: () -> T.Dict[str, str]
        return dict(
            type="enum",
            package="sym",
            name="type_t",
        )

    @classmethod
    def _default(cls):
        # type: () -> type_t
        # Return the first enum case
        return list(cls)[0]

    def encode(self):
        # type: () -> bytes
        buf = BytesIO()
        buf.write(self._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        # type: (T.BinaryIO) -> None
        buf.write(struct.pack('>i', self.value))

    @classmethod
    def decode(cls, data):
        # type: (T.Union[bytes, T.BinaryIO]) -> type_t
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != cls._get_packed_fingerprint():
            raise ValueError("Decode error")
        return cls._decode_one(buf)

    @classmethod
    def _decode_one(cls, buf):
        # type: (T.BinaryIO) -> type_t
        value = struct.unpack('>i', buf.read(4))[0]
        result = cls.from_int(value)
        if result is None:
            return cls._default()
        return result

    @T.overload
    @classmethod
    def from_int(cls, value, default):
        # type: (int, type_t) -> type_t
        pass

    @T.overload
    @classmethod
    def from_int(cls, value, default=None):  # pylint: disable=function-redefined
        # type: (int, None) -> T.Optional[type_t]
        pass

    @classmethod
    def from_int(cls, value, default=None):  # pylint: disable=function-redefined
        # type: (int, T.Optional[type_t]) -> T.Optional[type_t]
        """
        An alternative to "type_t(value)" which will return
        the given default instead of raising a ValueError for unknown values.
        """
        try:
            return cls(value)
        except ValueError:
            # Value unlisted / not associated with any case
            return default

    @classmethod
    def _get_hash_recursive(cls, parents):
        # type: (T.List[T.Type]) -> int
        if cls in parents:
            return 0
        tmphash = (0xa6869f09f492d897) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    @classmethod
    def _get_packed_fingerprint(cls):
        # type: () -> bytes
        return struct.pack(">Q", cls._get_hash_recursive([]))