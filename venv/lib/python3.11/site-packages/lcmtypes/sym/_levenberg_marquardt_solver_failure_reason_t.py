# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs

import typing as T

from io import BytesIO
import enum
import struct

class levenberg_marquardt_solver_failure_reason_t(enum.Enum):

    INVALID = 0
    LAMBDA_OUT_OF_BOUNDS = 1

    def __repr__(self):
        # type: () -> str
        return "{}.{}".format(self.__class__.__name__, self.name)

    @staticmethod
    def _skytype_meta():
        # type: () -> T.Dict[str, str]
        return dict(
            type="enum",
            package="sym",
            name="levenberg_marquardt_solver_failure_reason_t",
        )

    @classmethod
    def _default(cls):
        # type: () -> levenberg_marquardt_solver_failure_reason_t
        # Return the first enum case
        return list(cls)[0]

    def encode(self):
        # type: () -> bytes
        buf = BytesIO()
        buf.write(self._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        # type: (T.BinaryIO) -> None
        buf.write(struct.pack('>i', self.value))

    @classmethod
    def decode(cls, data):
        # type: (T.Union[bytes, T.BinaryIO]) -> levenberg_marquardt_solver_failure_reason_t
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != cls._get_packed_fingerprint():
            raise ValueError("Decode error")
        return cls._decode_one(buf)

    @classmethod
    def _decode_one(cls, buf):
        # type: (T.BinaryIO) -> levenberg_marquardt_solver_failure_reason_t
        value = struct.unpack('>i', buf.read(4))[0]
        result = cls.from_int(value)
        if result is None:
            return cls._default()
        return result

    @T.overload
    @classmethod
    def from_int(cls, value, default):
        # type: (int, levenberg_marquardt_solver_failure_reason_t) -> levenberg_marquardt_solver_failure_reason_t
        pass

    @T.overload
    @classmethod
    def from_int(cls, value, default=None):  # pylint: disable=function-redefined
        # type: (int, None) -> T.Optional[levenberg_marquardt_solver_failure_reason_t]
        pass

    @classmethod
    def from_int(cls, value, default=None):  # pylint: disable=function-redefined
        # type: (int, T.Optional[levenberg_marquardt_solver_failure_reason_t]) -> T.Optional[levenberg_marquardt_solver_failure_reason_t]
        """
        An alternative to "levenberg_marquardt_solver_failure_reason_t(value)" which will return
        the given default instead of raising a ValueError for unknown values.
        """
        try:
            return cls(value)
        except ValueError:
            # Value unlisted / not associated with any case
            return default

    @classmethod
    def _get_hash_recursive(cls, parents):
        # type: (T.List[T.Type]) -> int
        if cls in parents:
            return 0
        tmphash = (0xa6869f09f492d897) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    @classmethod
    def _get_packed_fingerprint(cls):
        # type: () -> bytes
        return struct.pack(">Q", cls._get_hash_recursive([]))