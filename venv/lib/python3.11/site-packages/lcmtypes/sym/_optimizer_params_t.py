# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs

import copy
import typing as T  # pylint: disable=unused-import

from io import BytesIO
import struct

class optimizer_params_t(object):
    __slots__ = ["verbose", "initial_lambda", "lambda_up_factor", "lambda_down_factor", "lambda_lower_bound", "lambda_upper_bound", "use_diagonal_damping", "use_unit_damping", "keep_max_diagonal_damping", "diagonal_damping_min", "iterations", "early_exit_min_reduction", "enable_bold_updates"]  # type: T.List[str]

    def __init__(
        self,
        verbose=False,  # type: bool
        initial_lambda=0.0,  # type: float
        lambda_up_factor=0.0,  # type: float
        lambda_down_factor=0.0,  # type: float
        lambda_lower_bound=0.0,  # type: float
        lambda_upper_bound=0.0,  # type: float
        use_diagonal_damping=False,  # type: bool
        use_unit_damping=False,  # type: bool
        keep_max_diagonal_damping=False,  # type: bool
        diagonal_damping_min=0.0,  # type: float
        iterations=0,  # type: int
        early_exit_min_reduction=0.0,  # type: float
        enable_bold_updates=False,  # type: bool
        _skip_initialize=False,  # type: bool
    ):
        # type: (...) -> None
        """ If _skip_initialize is True, all other constructor arguments are ignored """
        if _skip_initialize:
            return
        # Print information for every iteration?
        self.verbose = verbose
        # Damping value (lambda) on the first iteration of the LM loop
        self.initial_lambda = initial_lambda
        # Factor greater than one to multiply by lambda
        self.lambda_up_factor = lambda_up_factor
        # Factor less than one to multiply by lambda
        self.lambda_down_factor = lambda_down_factor
        # Smallest allowed value for lambda
        self.lambda_lower_bound = lambda_lower_bound
        # Largest allowed value for lambda
        self.lambda_upper_bound = lambda_upper_bound
        # Damp the Hessian adaptively based on the values on its diagonal?
        self.use_diagonal_damping = use_diagonal_damping
        # Damp the Hessian with a constant lambda?
        self.use_unit_damping = use_unit_damping
        # Use the elementwise max of the diagonal over all past iterations, instead
        # of the current diagonal? (Only used when use_diagonal_damping is turned on)
        self.keep_max_diagonal_damping = keep_max_diagonal_damping
        # Initial values of the diagonal when using keep_max_diagonal_damping (i.e.
        # if the max for a particular element on the diagonal is less than
        # diagonal_damping_min, that element of the diagonal is set to
        # diagonal_damping_min)
        self.diagonal_damping_min = diagonal_damping_min
        # Max number of LM iterations to run in an optimization
        self.iterations = iterations
        # Early exit from the optimization if the relative reduction is positive and
        # less than this amount
        self.early_exit_min_reduction = early_exit_min_reduction
        # Allow uphill movements in the optimization?
        self.enable_bold_updates = enable_bold_updates

    @staticmethod
    def from_all_fields(
        verbose,  # type: bool
        initial_lambda,  # type: float
        lambda_up_factor,  # type: float
        lambda_down_factor,  # type: float
        lambda_lower_bound,  # type: float
        lambda_upper_bound,  # type: float
        use_diagonal_damping,  # type: bool
        use_unit_damping,  # type: bool
        keep_max_diagonal_damping,  # type: bool
        diagonal_damping_min,  # type: float
        iterations,  # type: int
        early_exit_min_reduction,  # type: float
        enable_bold_updates,  # type: bool
    ):
        # type: (...) -> optimizer_params_t
        return optimizer_params_t(
            verbose=verbose,
            initial_lambda=initial_lambda,
            lambda_up_factor=lambda_up_factor,
            lambda_down_factor=lambda_down_factor,
            lambda_lower_bound=lambda_lower_bound,
            lambda_upper_bound=lambda_upper_bound,
            use_diagonal_damping=use_diagonal_damping,
            use_unit_damping=use_unit_damping,
            keep_max_diagonal_damping=keep_max_diagonal_damping,
            diagonal_damping_min=diagonal_damping_min,
            iterations=iterations,
            early_exit_min_reduction=early_exit_min_reduction,
            enable_bold_updates=enable_bold_updates,
        )

    @staticmethod
    def _skytype_meta():
        # type: () -> T.Dict[str, str]
        return dict(
            type="struct",
            package="sym",
            name="optimizer_params_t",
        )

    @classmethod
    def _default(cls):
        # type: () -> optimizer_params_t
        return cls()

    def __repr__(self):
        # type: () -> str
        return "optimizer_params_t({})".format(
            ", ".join("{}={}".format(name, repr(getattr(self, name))) for name in self.__slots__))

    def __eq__(self, other):
        # type: (object) -> bool
        if not isinstance(other, optimizer_params_t):
            return NotImplemented
        return (
            (self.verbose==other.verbose) and
            (self.initial_lambda==other.initial_lambda) and
            (self.lambda_up_factor==other.lambda_up_factor) and
            (self.lambda_down_factor==other.lambda_down_factor) and
            (self.lambda_lower_bound==other.lambda_lower_bound) and
            (self.lambda_upper_bound==other.lambda_upper_bound) and
            (self.use_diagonal_damping==other.use_diagonal_damping) and
            (self.use_unit_damping==other.use_unit_damping) and
            (self.keep_max_diagonal_damping==other.keep_max_diagonal_damping) and
            (self.diagonal_damping_min==other.diagonal_damping_min) and
            (self.iterations==other.iterations) and
            (self.early_exit_min_reduction==other.early_exit_min_reduction) and
            (self.enable_bold_updates==other.enable_bold_updates)
        )
    # Disallow hashing for python struct lcmtypes.
    __hash__ = None  # type: ignore

    def encode(self):
        # type: () -> bytes
        buf = BytesIO()
        buf.write(optimizer_params_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        # type: (T.BinaryIO) -> None
        buf.write(optimizer_params_t._CACHED_STRUCT_0.pack(self.verbose, self.initial_lambda, self.lambda_up_factor, self.lambda_down_factor, self.lambda_lower_bound, self.lambda_upper_bound, self.use_diagonal_damping, self.use_unit_damping, self.keep_max_diagonal_damping, self.diagonal_damping_min, self.iterations, self.early_exit_min_reduction, self.enable_bold_updates))

    @staticmethod
    def decode(data):
        # type: (T.Union[bytes, T.BinaryIO]) -> optimizer_params_t
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != optimizer_params_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return optimizer_params_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        # type: (T.BinaryIO) -> optimizer_params_t
        self = optimizer_params_t(_skip_initialize=True)
        self.verbose = bool(optimizer_params_t._CACHED_STRUCT_1.unpack(buf.read(1))[0])
        self.initial_lambda, self.lambda_up_factor, self.lambda_down_factor, self.lambda_lower_bound, self.lambda_upper_bound = optimizer_params_t._CACHED_STRUCT_2.unpack(buf.read(40))
        self.use_diagonal_damping = bool(optimizer_params_t._CACHED_STRUCT_1.unpack(buf.read(1))[0])
        self.use_unit_damping = bool(optimizer_params_t._CACHED_STRUCT_1.unpack(buf.read(1))[0])
        self.keep_max_diagonal_damping = bool(optimizer_params_t._CACHED_STRUCT_1.unpack(buf.read(1))[0])
        self.diagonal_damping_min, self.iterations, self.early_exit_min_reduction = optimizer_params_t._CACHED_STRUCT_3.unpack(buf.read(20))
        self.enable_bold_updates = bool(optimizer_params_t._CACHED_STRUCT_1.unpack(buf.read(1))[0])
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        # type: (T.List[T.Type]) -> int
        if optimizer_params_t in parents: return 0
        tmphash = (0x4bde142fb3887057) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    _packed_fingerprint = None  # type: T.Optional[bytes]

    @staticmethod
    def _get_packed_fingerprint():
        # type: () -> bytes
        if optimizer_params_t._packed_fingerprint is None:
            optimizer_params_t._packed_fingerprint = struct.pack(">Q", optimizer_params_t._get_hash_recursive([]))
        return optimizer_params_t._packed_fingerprint

    def deepcopy(self, **kwargs):
        # type: (**T.Any) -> optimizer_params_t
        """
        Deep copy of this LCM type

        Returns a copy w/ members specified by kwargs replaced with new values specified by kwargs.
        """
        result = copy.deepcopy(self)
        for key in kwargs:
            if not hasattr(result, key):
                raise KeyError("Type optimizer_params_t does not have attribute: " + str(key))
            setattr(result, key, kwargs[key])
        return result

    _CACHED_STRUCT_0 = struct.Struct(">bdddddbbbdidb")
    _CACHED_STRUCT_1 = struct.Struct("b")
    _CACHED_STRUCT_2 = struct.Struct(">ddddd")
    _CACHED_STRUCT_3 = struct.Struct(">did")
